# 快速陷入处理

[![CI](https://github.com/YdrMaster/fast-trap/actions/workflows/workflow.yml/badge.svg?branch=main)](https://github.com/YdrMaster/fast-trap/actions)
[![issue](https://img.shields.io/github/issues/YdrMaster/fast-trap)](https://github.com/YdrMaster/fast-trap/issues)
![license](https://img.shields.io/github/license/YdrMaster/fast-trap)

这个库提供一套裸机应用程序陷入处理流程的框架，旨在保证处理性能的同时尽量复用代码。

## 目录

- [概念](#概念)
- [使用说明](#使用说明)
  - [全局初始化](#全局初始化)
  - [陷入栈](#陷入栈)
  - [陷入快速路径](#陷入快速路径)
  - [控制流切换](#控制流切换)
  - [根控制流](#根控制流)

## 概念

**陷入**是硬件的异步机制，由于异常或中断，一个连续的控制流会被硬件打断，形成两级结构。如果软件支持嵌套陷入，还可能产生多级的控制流。这些由于嵌套陷入而产生的上下文构成了一个树状结构。下图展示了一个控制流发生 2 级嵌套的陷入时的结构：

```plaintext
root flow ----*----------*---->
             / \        / \
            /   \      /   - - - - - - - - - -
           /     \    /                       \
trap Lv.1  ------>    -----*-------------*---->
                          / \           / \
                         /   \         /   \
                        /     \       /     \
trap Lv.2               ------>       ------>
```

这个库定义了如何在嵌套的陷入中管理多个控制流。所有控制流被分为由用户主动构造的**根控制流**和硬件陷入产生的**非根控制流**。对于根控制流，库并不干涉，用户可以自由地定义其结构和管理方式。非根控制流的基本结构被库限定，以实现对其切换操作的封装。

## 使用说明

### 全局初始化

库提供了一个陷入处理例程，这个入口需要加载到硬件。使用下面这个函数可以完成这个操作：

```rust
pub unsafe fn load_direct_trap_entry()
```

这个函数将陷入配置为直接模式。若要使用中断向量表，可以通过 `trap` 函数找到入口地址。

### 陷入栈

高级语言必须有一个栈，陷入产生一个新的控制流，必然伴随着栈切换。在陷入发生前，必须先为其准备一个陷入栈。陷入栈定义为一个在地址空间上连续的内存块：

```rust
struct TrapStack<B: AsRef<[u8]> + AsMut<[u8]>, T>(B, PhantomData<T>);
```

- 类型 `B` 允许用户自由选择内存块的所有权管理方式，例如使用 `Vec` 或智能指针
- 类型 `T` 用于**陷入快速路径**。陷入快速路径的信息将在[下一节](#陷入快速路径)介绍

这个内存块必须满足一定的条件以存放切换时必要的信息。使用 `new` 函数可以检查其是否满足条件，然后构造出栈对象：

```rust
fn new(mut block: B, fast_handler: FastHandler<T>) -> Result<Self, IllegalStack>
```

- 参数 `block` 是将作为栈的内存块
- 参数 `fast_handler` 是陷入快速路径函数的函数指针

然后使用 `load` 函数将陷入栈的关键信息配置到硬件寄存器：

```rust
unsafe fn load(&mut self) -> usize
```

调用这个方法后，这个栈就成为预备的陷入栈。一旦陷入发生，将在这个栈上调用其快速路径函数，进行陷入处理。

#### 陷入嵌套

一旦一个陷入发生，控制流将转移到陷入栈的处理函数，同时，中断也被屏蔽。陷入处理可能是缓慢的，由于实时性要求，不能一直关闭中断，也不能排除进一步的异常，这就需要陷入嵌套。在陷入处理函数中，可以构造另一个陷入栈。只要按上述操作将其加载为预备陷入栈，就可以处理陷入控制流上的嵌套陷入了。

#### 陷入栈回收

对于嵌套的陷入栈，高级栈的生命周期是不可能超过低级栈的。

或者，另一种理解是**陷入栈是对控制流的保护**。对于这个库提供的框架来说，陷入、恢复以及任务的切换过程中是不会发生陷入的，所以也不需要保护。因此，所有控制流都是**结构化的**。因此，对于一般的情况，只需要将低级栈的 RAII 对象限定在高级语言陷入处理上下文中，就可以在低级陷入完成时自动回收陷入栈。

### 陷入快速路径

从发生陷入，到第一次进入高级语言处理函数，之间执行的指令就是陷入的**开销**。即发生一次陷入的必要代价。必须尽量降低这个开销，才能提升陷入处理的实时性。之所以要执行这些指令，是因为高级语言的编译器会自动安排寄存器的用法，而陷入发生时，通用寄存器里正保存着陷入现场的信息，必须将这些寄存器的值转存以保护现场。

但对于编译器来说，寄存器分为调用者保存的和被调用者保存的，被调用者保存的寄存器，编译器会自动保护。如果陷入处理不关心这些寄存器的值就不需要在固定的汇编里保存它们。幸好，陷入处理常常不关心它们。因此，陷入发生的第一时间，可以只保存一小部分寄存器以获得最优的处理延迟，这就是所谓的**陷入快速路径**。

在快速路径中，只能查、改陷入现场的一部分寄存器。对于 RISC-V 来说，这些寄存器包括：返回地址 `ra`、指针 `sp`、`gp` 和 `tp`，以及所有的临时寄存器 `t0-t6` 和参数寄存器 `a0-a7`。其中参数寄存器是按照调用规范直接传递到高级语言内的，并未保存到上下文对象。另外，陷入栈的定义保证了发生陷入时一定会进入一个干净的上下文，不需要恢复。所以，从发生陷入到进入快速路径，只需要 14 个指令（其中 11 个是访存的）：

```rust
// 换栈
"   csrrw sp, sscratch, sp",
// 加载上下文指针
"   sd    a0,  0*8(sp)
    ld    a0,  1*8(sp)
",
// 保存尽量少的寄存器
"   sd    ra,  0*8(a0)
    sd    t0,  1*8(a0)
    sd    t1,  2*8(a0)
    sd    t2,  3*8(a0)
    sd    t3,  4*8(a0)
    sd    t4,  5*8(a0)
    sd    t5,  6*8(a0)
    sd    t6,  7*8(a0)
",
// 调用快速路径函数
"   mv    a0,      sp
    ld    ra,  2*8(sp)
    jalr  ra
",
```

如果处理流程关心未保存的那些寄存器，就必须离开快速路径，保存剩余的寄存器再重新进入，这称为**陷入完整路径**。这种情况一般出现在需要切换控制流的陷入，例如时钟中断或 `yield` 类型的系统调用，因为这时必须将完整的陷入现场打包保存。因此，快速路径函数的定义如下：

```rust
type FastHandler<T> = extern "C" fn(
    ctx: &mut FastContext<T>,
    a1: usize,
    a2: usize,
    a3: usize,
    a4: usize,
    a5: usize,
    a6: usize,
    a7: usize,
) -> FastResult;
```

它可以通过返回值通知框架是否需要进入完整路径。然而，快速路径中可能还有一些计算结果需要传递给完整路径继续处理，但这两个部分被分隔开了，无法通过栈传递。因此，库模仿协程的方式，在陷入栈上预留了一个虚拟栈区用于在从快速路径转移到完整路径的过程中暂存信息，即陷入栈的泛型 `T`。快速路径可以设置一个 `T` 对象，然后在完整路径中读取。

### 控制流切换

WIP

### 根控制流

WIP
