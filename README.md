# 快速陷入处理

[![CI](https://github.com/YdrMaster/fast-trap/actions/workflows/workflow.yml/badge.svg?branch=main)](https://github.com/YdrMaster/fast-trap/actions)
[![issue](https://img.shields.io/github/issues/YdrMaster/fast-trap)](https://github.com/YdrMaster/fast-trap/issues)
![license](https://img.shields.io/github/license/YdrMaster/fast-trap)

这个库提供一套裸机应用程序陷入处理流程的框架，旨在保证处理性能的同时尽量复用代码。

## 目录

- [概念](#概念)
- [使用说明](#使用说明)
  - [全局初始化](#全局初始化)
  - [陷入栈](#陷入栈)
  - [陷入快速路径](#陷入快速路径)
  - [控制流切换](#控制流切换)

## 概念

**陷入**是硬件的异步机制，由于异常或中断，一个连续的控制流会被硬件打断，形成两级结构。如果软件支持嵌套陷入，还可能产生多级的控制流。这些由于嵌套陷入而产生的上下文构成了一个树状结构。下图展示了一个控制流发生 2 级嵌套的陷入时的结构：

```plaintext
root flow ----*----------*---->
             / \        / \
            /   \      /   - - - - - - - - - -
           /     \    /                       \
trap Lv.1  ------>    -----*-------------*---->
                          / \           / \
                         /   \         /   \
                        /     \       /     \
trap Lv.2               ------>       ------>
```

这个库定义了如何在嵌套的陷入中管理多个控制流。所有控制流被分为由用户主动构造的**根控制流**和硬件陷入产生的**非根控制流**。对于根控制流，库并不干涉，用户可以自由地定义其结构和管理方式。非根控制流的基本结构被库限定，以实现对其切换操作的封装。

## 使用说明

### 全局初始化

库提供了一个陷入处理例程，这个入口需要加载到硬件。使用下面这个函数可以完成这个操作：

```rust
pub unsafe fn load_direct_trap_entry()
```

这个函数将陷入配置为直接模式。若要使用中断向量表，可以通过 `trap` 函数找到入口地址。

### 陷入栈

高级语言必须有一个栈，陷入产生一个新的控制流，必然伴随着栈切换。在陷入发生前，必须先为其准备一个陷入栈。陷入栈定义为一个在地址空间上连续的内存块：

```rust
struct TrapStack<B: AsRef<[u8]> + AsMut<[u8]>, T>(B, PhantomData<T>);
```

- 类型 `B` 允许用户自由选择内存块的所有权管理方式，例如使用 `Vec` 或智能指针
- 类型 `T` 用于**陷入快速路径**。陷入快速路径的信息将在[下一节](#陷入快速路径)介绍

这个内存块必须满足一定的条件以存放切换时必要的信息。使用 `new` 函数可以检查其是否满足条件，然后构造出栈对象：

```rust
fn new(mut block: B, fast_handler: FastHandler<T>) -> Result<Self, IllegalStack>
```

- 参数 `block` 是将作为栈的内存块
- 参数 `fast_handler` 是陷入快速路径函数的函数指针

然后使用 `load` 函数将陷入栈的关键信息配置到硬件寄存器：

```rust
unsafe fn load(&mut self) -> usize
```

调用这个方法后，这个栈就成为预备的陷入栈。一旦陷入发生，将在这个栈上调用其快速路径函数，进行陷入处理。

#### 陷入嵌套

一旦一个陷入发生，控制流将转移到陷入栈的处理函数，同时，中断也被屏蔽。陷入处理可能是缓慢的，由于实时性要求，不能一直关闭中断，也不能排除进一步的异常，这就需要陷入嵌套。在陷入处理函数中，可以构造另一个陷入栈。只要按上述操作将其加载为预备陷入栈，就可以处理陷入控制流上的嵌套陷入了。

### 陷入栈回收

对于嵌套的陷入栈，高级栈的生命周期是不可能超过低级栈的。因此，对于一般的情况，只需要将低级栈的 RAII 对象限定在高级语言陷入处理上下文中，就可以在低级陷入完成时自动回收陷入栈。

### 陷入快速路径

WIP

### 控制流切换

WIP
